import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Docs/Introduction" />

# プロジェクト理念：「手書き」のカタログ

## 目的

このリポジトリの主な目的は、AIエージェントにとっての**模範的な参照元（いわば「人間が書いた手本」）**となることである。私の個人的なコーディングスタイルを反映した、バニラなHTML/CSS/JSコンポーネント集を整備することで、以下の実現を目指している。

1.  **コールドスタート問題の解消**: AIが模倣すべき明確なターゲットを提供し、スタイルや構造について毎回詳細な指示を出す手間を省く。
2.  **品質の担保**: 自動生成されるコードが、セマンティックなHTML、アクセシブルなCSS、クリーンなJavaScriptという高い基準を満たすようにする。
3.  **将来への備え**: モデルのファインチューニングや、将来的なWeb開発タスクにおけるFew-shotプロンプティングの例として使えるデータセットを構築する。

## コア原則

### 1. バニラファースト

- **フレームワーク非依存**: 標準的なHTML、CSS、JavaScriptを使用する。これにより、特定の技術に依存しない持続性と高い移植性を確保する。
- **ブラウザネイティブ**: ビルドツールによるポリフィルに頼るのではなく、ES Modules、CSS Variables、Grid/Flexboxといった最新のブラウザ機能を可能な限り活用する。

### 2. アーキテクチャの核：「APIとしてのCSS」

私たちは、**命令的な上書き**から**リアクティブかつAPI駆動なスタイリング**へと移行することで、「カスケードの競合」や「詳細度の地獄」といったCSS特有の問題を解決する。

#### 問題点

従来のCSSでは、親要素が子要素のスタイルを強制的に上書きすることがよくある（例：`.card .button { background: red !important; }`）。これは以下のような弊害をもたらす。

- **脆さ**: 子要素の内部構造が変わると、親からの上書きが機能しなくなる。
- **詳細度の競争**: スタイルを適用させるために `!important` や深いネスト構造を乱用してしまう。
- **予測不能な副作用**: スタイルが意図せず他の箇所に漏れ出たり、競合したりする。

#### 解決策：コンテキスト認識コンポーネント

スタイルを直接上書きするのではなく、**パラメータ（CSS変数）**を渡すというアプローチを採る。

- **API駆動**: コンポーネントは自身のパブリックAPI（`--variant` などの変数）を定義する。
- **リアクティブ**: コンポーネントはこれらの変数を監視し（`@container style(...)` を使用）、自分自身を*どのように*描画するかを決定する。
- **カプセル化**: 親要素はボタンが*どのように*赤くなるかを知る必要はない。単に「danger（危険）」というコンテキストを要求するだけである。

> **「コンポーネントに『どう見えるべきか』を命令するのではなく、『どのような状況にあるか』を伝える。」**

### 3. レイアウト：「グリッドファースト」と「マージンなし」

私たちは、**レイアウト**（配置や余白）と**コンポーネント**（見た目や装飾）を明確に分離する。

#### 「マージンなし」の原則

コンポーネント（`c-`）は、**原則として**外部マージンを持ってはいけない。

- **理由**: マージンを持たせると、コンポーネントが配置場所に依存してしまう。例えば `margin-inline-end: 20px` を持つボタンは、行の末尾やサイドバーに置かれた際に不自然な余白を生んでしまう。
- **ルール**: 「コンポーネントは自身の描画領域（パディングやボーダー）のみに関心を持ち、レイアウトが余白（ギャップやグリッド）を管理する。」

#### 「グリッドファースト」アプローチ

レイアウト（`l-`）は、構造と余白を定義するためにCSS Gridを積極的に使用する。

- **マージンよりギャップ**: 均一な余白には `gap` プロパティを使用する。
- **トラックによる余白**: マージンの代わりに、`grid-template-columns/rows` を使って余白用のトラック（例：`1fr 20px 100px`）を定義する。
- **明示的なエリア**: `c-` コンポーネントを `l-` コンテナでラップし、コンポーネント自体が配置に関知しないようにする。

**例:**

```html
<div class="l-grail">
	<div class="l-grail__header">
		<header class="c-header">...</header>
	</div>
	<div class="l-grail__main">
		<main class="c-main">...</main>
	</div>
	<div class="l-grail__side">
		<aside class="c-side">...</aside>
	</div>
	<div class="l-grail__footer">
		<footer class="c-footer">...</footer>
	</div>
</div>
```

```css
.l-grail {
	display: grid;
	grid-template-columns: 1fr 40px 300px;
	grid-template-rows: auto 60px 1fr 80px auto;
	grid-template-areas:
		'header header header'
		'.      .      .'
		'main   .      side'
		'.      .      .'
		'footer footer footer';
}

.l-grail__header {
	grid-area: header;
}
.l-grail__main {
	grid-area: main;
}
.l-grail__side {
	grid-area: side;
}
.l-grail__footer {
	grid-area: footer;
}
```

#### 例外：マージンを使用する場合

*コンポーネント*でのマージンは避けるが、特定の状況では `margin` が必要不可欠である。

1.  **フローコンテンツ（タイポグラフィと記事）** [重要]
    - **状況**: ブログ記事やドキュメントなど、要素が自然に積み重なる長文テキストの中。
    - **使用法**: 見出し、段落、リスト間の垂直方向のリズムを作るために `margin-block-end` または `margin-block-start` を使用する。
    - **理由**: 単に `gap` を使うためだけにすべての段落をGridやFlexコンテナで囲むのは過剰であり、HTMLのセマンティクスを損なうためである。

2.  **自動整列（Auto Margins）**
    - **使用法**: Flexコンテナ内で要素を片側に寄せるために `margin-inline-start: auto` などを使用する。
    - **理由**: これは `gap` では代替できない、強力なレイアウトテクニックである。

3.  **視覚的な微調整**
    - **使用法**: 視覚的なバランスを整えるためのネガティブマージンや、文字の食い込み調整（オプティカルアライメント）など。

### 4. コンポーネント設計と命名規則

#### 命名規則

- **略語の禁止**: 明確さを優先し、完全な単語を使用する。
  - _良い_: `button`, `navigation`, `card`
  - _悪い_: `btn`, `nav`, `cd`
- **プレフィックス**:
  - **`c-` (Component)**: UIパーツ（例：`c-button`, `c-card`）。
  - **`l-` (Layout)**: コンポーネントを配置するための構造的コンテナ（例：`l-grid`, `l-container`）。
    - レイアウトは見た目（色、影）のスタイルを持たず、幾何学的なプロパティ（グリッド、フレックス、余白）のみを持つ。
    - レイアウトは `c-` コンポーネントを内包する。

#### 修飾子と状態

- **コンテキストスタイリング（スタイルクエリ）**: バリエーションの制御にはCSSコンテナクエリ（`@container style(...)`）を使用する。
  - **コンセプト**: コンポーネントは、親から継承された、あるいは自身に設定されたCSS変数に基づいて適応する。
  - **実装**:
    1.  コンポーネントまたはその親にカスタムプロパティ（例：`--variant`）を定義する。
    2.  `@container style(--variant: value)` を使用して、特定のスタイルを適用する。
  - **利点**: スタイルを特定のクラス名から切り離し、「コンテキストに応じたスタイリング」（例：暗いカードの中に置かれたボタンは自動的に明るい色になる）を可能にする。

**例:**

```html
<!-- HTML -->
<button class="c-button" style="--variant: primary">Button</button>
```

```css
/* CSS */
.c-button {
	/* デフォルトスタイル */
	background: #eee;
	color: #333;
}

/* --variant: primary が継承または設定されている場合にスタイルを適用 */
@container style(--variant: primary) {
	.c-button {
		background: blue;
		color: white;
	}
}
```

### 5. インタラクション：「スクリプトよりネイティブ」

私たちは、HTMLとCSSの進化し続ける機能を信頼し、可能な限りJavaScriptを使わずにUIインタラクションを実装するよう努める。

- **JSゼロの原則**: イベントリスナーを書く前に、「これはHTML/CSSだけで実現できないか？」と自問する。
- **最新のプリミティブ**: アコーディオンには `<details>`、モーダルには `<dialog>`、オーバーレイには `:popover`、そしてスクロール連動アニメーションなどを活用する。
- **CSSによる状態管理**: UIの状態変化には `:checked`、`:target`、`:focus-within` などの擬似クラスを活用する。
- **JSの役割**: JavaScriptは、ビジネスロジック、API通信、そしてHTMLだけではどうしても処理できない複雑な状態管理のためにのみ使用する。

### 6. AI可読性への配慮

このリポジトリをAIの学習データとして最大限活用するために、以下のルールを守る。

- **明示的なPropsマッピング**: Storybookの `args` は、HTML属性やCSSクラスに直接対応するようにする。これにより、AIは要件（例：「プライマリボタン」）と実装（`.btn--primary`）の因果関係を学習しやすくなる。
- **バリエーションと状態**: 「正常系」だけでなく、エッジケースも網羅する。`disabled`、`loading`、`empty`、`error` などの状態を明示的に実装し、文書化する。
- **コンテキストコメント**: *何をしているか*だけでなく、*なぜそうしているか*をコメントで説明する。
  - _良い_: `/* z-index: 10; ヘッダーがヒーローコンテンツの上に重なるようにするため */`
  - _悪い_: `/* z-index: 10; */`

### 7. コーディングスタイルガイド

#### タイポグラフィと単位

- **フォントサイズ**: 基本的に `rem` または `em` を使用する。
- **コンポーネントルート**: 常に `font-size: 1rem;` を指定して、参照フォントサイズをリセットする。
- **テキストプロパティ**: `line-height` と `letter-spacing` には `em` または単位なしの値を使用する。
- **スペーシング（パディング/マージン/ギャップ）**: `px` を使用する。
  - _根拠_: インラインのスペーシングに `rem`/`em` を使用すると、ルートのフォントサイズが大きくなったときに幅が過剰に広がり、ブラウザの幅が変わっていなくてもレイアウト崩れを起こす可能性がある。`px` を使うことで、より予測可能なスペーシングを維持できる。

#### CSS変数（カスタムプロパティ）

コンポーネントでは、**パブリック/プライベートAPIパターン**を採用している。

##### プライベート変数（実装）

- **プレフィックス**: `--_`（アンダースコア）
- **定義**: コンポーネントのスタイル設定に使用される内部変数。
- **役割**: カプセル化。コンポーネントの外部からこれらを設定または読み取ることは避ける。
- **命名パターン**: `--_{property}`（簡潔さのためにコンポーネント名は省略される）

##### パブリック変数（API）

- **プレフィックス**: `--{component}-{property}`
- **定義**: カスタマイズのために公開されるパブリックインターフェース。
- **役割**: 外部からコンポーネントスタイルをオーバーライドするためにこれらを使用する。
- **命名パターン**: `--c-button-bg`, `--l-grid-gap`

##### フォールバックチェーン

コンポーネントは、最初にパブリックAPI変数をチェックし、次にセマンティックトークン（デフォルト）にフォールバックすることで、プライベート変数を明示的に初期化する。

**例:**

```css
.c-button {
	/* プライベート変数 = パブリックAPI（設定されている場合） ?? システムトークン（デフォルト） */
	--_bg: var(--c-button-bg, var(--sys-bg-action));

	font-size: 1rem; /* 参照サイズをリセット */
	background: var(--_bg); /* 実装はプライベート変数を使用 */
	padding: 16px; /* スペーシングにはpxを使用 */
}
```

この構造により、以下が保証される：

1.  **カプセル化**: 内部ロジック（`--_bg`）は外部入力から分離されている。
2.  **カスタマイズ性**: コンシューマーは、詳細度と戦うことなく、`--c-button-bg` を設定して色をオーバーライドできる。
3.  **安全性**: オーバーライドが提供されない場合、システムトークンが安全なデフォルトとして使用される。

## 今後のロードマップ

このリポジトリの「教材」としての質を高めるために、以下の拡充を予定している。

- [ ] **コンポーネントカタログの拡大**: 一般的なUIパターン（フォーム、モーダル、ナビゲーション、フッターなど）を網羅する。
- [ ] **アンチパターンの文書化**: AIが陥りがちな間違いを防ぐために、「やってはいけないこと」をまとめたセクションを作成する。
- [ ] **セマンティックHTMLの実例**: 複雑なドキュメント構造（article, aside, section, dl/dt/ddなど）の適切な使用例を追加する。
